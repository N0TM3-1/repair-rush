local machines = require 'modules.machines'

go.property("speed", 200)         -- Max movement speed
go.property("acceleration", 6000) -- Rate of acceleration
go.property("friction", 3000)     -- Rate of deceleration

go.property("interaction_distance", 300)

local distances = {}
local input_velocity = vmath.vector3(0, 0, 0)

local velocity = vmath.vector3(0, 0, 0)
local input_states = { right = false, left = false, up = false, down = false }
local input_dir = vmath.vector3(0, 0, 0)
local move = {}


local function update_input()
	input_dir.x = (input_states.right and 1 or 0) - (input_states.left and 1 or 0)
	input_dir.y = (input_states.up and 1 or 0) - (input_states.down and 1 or 0)
end

function move.x(self, dt)
	-- Apply acceleration on key press
	if input_dir.x ~= 0 then
		velocity.x = velocity.x + input_dir.x * self.acceleration * dt
	end

	-- Apply friction when no input is given
	if velocity.x > 0 then
		velocity.x = math.max(velocity.x - self.friction * dt, 0)
	end

	if velocity.x < 0 then
		velocity.x = math.min(velocity.x + self.friction * dt, 0)
	end
end

function move.y(self, dt)
	-- Apply acceleration on key press
	if input_dir.y ~= 0 then
		velocity.y = velocity.y + input_dir.y * self.acceleration * dt
	end

	-- Apply friction when no input is given
	if velocity.y > 0 then
		velocity.y = math.max(velocity.y - self.friction * dt, 0)
	end

	if velocity.y < 0 then
		velocity.y = math.min(velocity.y + self.friction * dt, 0)
	end
end

function move.limit(self, dt)
	-- Limit speed
	local speed = vmath.length(velocity)
	if speed > self.speed then
		velocity = vmath.normalize(velocity) * self.speed
	end
end

function move.apply(self, dt)
	-- Apply movement
	local pos = go.get_position()
	pos = pos + velocity * dt
	go.set_position(pos)
end

local function get_distance(other_url)
	local self_pos = go.get_position()
	local other_pos = go.get_position(other_url)
	return vmath.length(self_pos - other_pos)
end

local function get_smallest()
	local smallest = 999999 -- Larger than possible distances
	local smallest_index = ""
	for k, v in pairs(distances) do
		if v < smallest then
			smallest = v
			smallest_index = k
		end
	end
	return smallest_index
end

function init(self)
	msg.post(".", "acquire_input_focus")
end

function update(self, dt)
	update_input()
	move.x(self, dt)
	move.y(self, dt)
	move.limit(self, dt)
	move.apply(self, dt)
end

local function update_key_press(var_table, key_name, action)
	if action.pressed then
		var_table[key_name] = true
	elseif action.released then
		var_table[key_name] = false
	end
end

function on_input(self, action_id, action)
	if action_id == hash("east") then
		update_key_press(input_states, "right", action)
	elseif action_id == hash("west") then
		update_key_press(input_states, "left", action)
	elseif action_id == hash("north") then
		update_key_press(input_states, "up", action)
	elseif action_id == hash("south") then
		update_key_press(input_states, "down", action)
	end
	if action_id == hash("action_right") and action.pressed then
		for k, v in pairs(machines) do
			distances[v] = get_distance(v)
		end
		local url = get_smallest()
		msg.post(url, "start_minigame")
		msg.post(".", "release_input_focus")
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("game_ended") then
		msg.post(".", "acquire_input_focus")
	elseif message_id == hash("contact_point_response") then
		-- Handle collision with walls or other objects
		local normal = message.normal
		local distance = message.distance

		-- Stop movement in the direction of the collision
		if math.abs(normal.x) > 0.7 then
			-- Horizontal collision (wall on left/right)
			velocity.x = 0
			input_velocity.x = 0
		end
		if math.abs(normal.y) > 0.7 then
			-- Vertical collision (wall on top/bottom)
			velocity.y = 0
			input_velocity.y = 0
		end

		-- Optionally, you can separate the object from the collision
		if distance > 0 then
			local pos = go.get_position()
			pos = pos + normal * distance
			go.set_position(pos)
		end
	end
end
